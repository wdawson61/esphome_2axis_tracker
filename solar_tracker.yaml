esphome:
  name: solar-tracker
  friendly_name: "2-Axis Solar Tracker"
  platformio_options:
    board_build.flash_mode: dio
  
esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Enable fallback hotspot in case wifi connection fails
  ap:
    ssid: "Solar-Tracker Fallback"
    password: !secret ap_password

# Web server for configuration and monitoring
web_server:
  port: 80

# UART for RS485 communication with WIT-Motion HWT905
uart:
  id: uart_bus
  tx_pin: GPIO16
  rx_pin: GPIO17
  baud_rate: 115200
  data_bits: 8
  parity: NONE
  stop_bits: 1

# Custom component for WIT-Motion HWT905 sensor
external_components:
  - source:
      type: local
      path: components
    components: [ wit_motion ]

# WIT-Motion HWT905 sensor
sensor:
  - platform: wit_motion
    uart_id: uart_bus
    
    # Acceleration sensors
    acceleration_x:
      name: "Acceleration X"
      unit_of_measurement: "m/s²"
      accuracy_decimals: 3
    
    acceleration_y:
      name: "Acceleration Y"
      unit_of_measurement: "m/s²"
      accuracy_decimals: 3
    
    acceleration_z:
      name: "Acceleration Z"
      unit_of_measurement: "m/s²"
      accuracy_decimals: 3
    
    # Angular velocity (gyroscope)
    angular_velocity_x:
      name: "Angular Velocity X"
      unit_of_measurement: "°/s"
      accuracy_decimals: 2
    
    angular_velocity_y:
      name: "Angular Velocity Y"
      unit_of_measurement: "°/s"
      accuracy_decimals: 2
    
    angular_velocity_z:
      name: "Angular Velocity Z"
      unit_of_measurement: "°/s"
      accuracy_decimals: 2
    
    # Angle (orientation)
    roll:
      name: "Roll Angle"
      unit_of_measurement: "°"
      accuracy_decimals: 2
    
    pitch:
      name: "Pitch Angle"
      unit_of_measurement: "°"
      accuracy_decimals: 2
    
    heading:
      name: "Heading"
      unit_of_measurement: "°"
      accuracy_decimals: 2
    
    # Temperature sensor
    temperature:
      name: "IMU Temperature"
      unit_of_measurement: "°C"
      accuracy_decimals: 1

# Output pins for elevation motor (H-bridge control)
output:
  - platform: gpio
    pin: GPIO4
    id: elevation_motor_forward
  
  - platform: gpio
    pin: GPIO5
    id: elevation_motor_backward

# Azimuth motor control outputs (for future use)
  - platform: gpio
    pin: GPIO6
    id: azimuth_motor_forward
  
  - platform: gpio
    pin: GPIO7
    id: azimuth_motor_backward

# Global variables to track motor state
globals:
  - id: elevation_target_angle
    type: float
    restore_value: no
    initial_value: '0.0'
  
  - id: current_elevation_angle
    type: float
    restore_value: no
    initial_value: '0.0'

# Script to control elevation motor
script:
  - id: set_elevation_angle
    mode: restart
    parameters:
      target_angle: float
    then:
      - lambda: |-
          id(elevation_target_angle) = target_angle;
          float current_angle = id(current_elevation_angle);
          float angle_diff = target_angle - current_angle;
          
          ESP_LOGD("elevation", "Target: %.2f, Current: %.2f, Diff: %.2f", 
                   target_angle, current_angle, angle_diff);
          
          // Stop motors first
          id(elevation_motor_forward).turn_off();
          id(elevation_motor_backward).turn_off();
          
          if (abs(angle_diff) < 0.5) {
            // Already at target angle
            ESP_LOGD("elevation", "Already at target angle");
            return;
          }
          
          // Determine direction and run motor
          if (angle_diff > 0) {
            // Move forward (increase elevation)
            ESP_LOGD("elevation", "Moving forward");
            id(elevation_motor_forward).turn_on();
            id(elevation_motor_backward).turn_off();
          } else {
            // Move backward (decrease elevation)
            ESP_LOGD("elevation", "Moving backward");
            id(elevation_motor_forward).turn_off();
            id(elevation_motor_backward).turn_on();
          }
          
          // Calculate run time based on angle difference
          // Assuming ~1 degree per second movement
          float run_time_ms = abs(angle_diff) * 1000.0;
      
      - delay: !lambda "return abs(id(elevation_target_angle) - id(current_elevation_angle)) * 1000.0;"
      
      - lambda: |-
          // Stop motors
          id(elevation_motor_forward).turn_off();
          id(elevation_motor_backward).turn_off();
          
          // Update current angle
          id(current_elevation_angle) = id(elevation_target_angle);
          ESP_LOGD("elevation", "Movement complete. New angle: %.2f", id(current_elevation_angle));

  - id: stop_elevation_motor
    mode: single
    then:
      - lambda: |-
          id(elevation_motor_forward).turn_off();
          id(elevation_motor_backward).turn_off();
          ESP_LOGD("elevation", "Motor stopped");

# Button to manually test motor control
button:
  - platform: template
    name: "Stop Elevation Motor"
    on_press:
      - script.execute: stop_elevation_motor

# Number input for setting elevation angle
number:
  - platform: template
    name: "Target Elevation Angle"
    id: target_elevation_input
    min_value: -90
    max_value: 90
    step: 1
    mode: box
    unit_of_measurement: "°"
    optimistic: true
    on_value:
      then:
        - script.execute:
            id: set_elevation_angle
            target_angle: !lambda "return x;"

# Text sensor to display system status
text_sensor:
  - platform: template
    name: "Tracker Status"
    id: tracker_status
    update_interval: 1s
    lambda: |-
      char buffer[100];
      snprintf(buffer, sizeof(buffer), 
               "Elevation: %.1f° | Target: %.1f°", 
               id(current_elevation_angle), 
               id(elevation_target_angle));
      return std::string(buffer);
